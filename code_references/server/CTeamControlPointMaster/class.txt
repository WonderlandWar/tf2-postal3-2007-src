class CTeamControlPointMaster : public CBaseEntity
{
    public char * GetTriggerAreaCaptureName();
    public char * GetControlPointName();
    public char * GetControlPointRoundName();
    public void Spawn();
    public bool KeyValue(char * ,char * );
    public void Precache();
    public void Activate();
    public void RoundRespawn();
    public void Reset();
    public int GetNumPoints();
    public int GetNumPointsOwnedByTeam(int );
    public int CalcNumRoundsRemaining(int );
    public bool IsActive();
    public void FireTeamWinOutput(int );
    public bool PointCanBeCapped(class CTeamControlPoint * );
    public void CheckWinConditions();
    public bool WouldNewCPOwnerWinGame(class CTeamControlPoint * ,int );
    public int GetBaseControlPoint(int );
    public bool IsBaseControlPoint(int );
    public bool PlayingMiniRounds();
    public float PointLastContestedAt(int );
    public class CTeamControlPoint * GetControlPoint(int );
    public class CTeamControlPointRound * GetCurrentRound();
    public void FireRoundStartOutput();
    public void FireRoundEndOutput();
    public void ListRounds();
    private void CPMThink();
    private void SetBaseControlPoints();
    private int TeamOwnsAllPoints(class CTeamControlPoint * ,int );
    private bool FindControlPoints();
    private bool FindControlPointRounds();
    private bool GetControlPointRoundToPlay();
    private bool SelectSpecificRound();
    private bool FindControlPointRoundToPlay();
    private void RegisterRoundBeingPlayed();
    private class CUtlMap<int,CTeamControlPoint *,unsigned short> m_ControlPoints;
    private bool m_bFoundPoints;
    private class CUtlVector<CTeamControlPointRound *,CUtlMemory<CTeamControlPointRound *,int> > m_ControlPointRounds;
    private int m_iCurrentRoundIndex;
    private struct datamap_t m_DataMap;
    private struct datamap_t * GetBaseMap();
    private struct datamap_t * GetDataDescMap();
    private bool m_bDisabled;
    private void InputEnable(struct inputdata_t & );
    private void InputDisable(struct inputdata_t & );
    private void InputRoundSpawn(struct inputdata_t & );
    private void InputRoundActivate(struct inputdata_t & );
    private void InputSetWinner(struct inputdata_t & );
    private void InputSetWinnerAndForceCaps(struct inputdata_t & );
    private void InputSetCapLayout(struct inputdata_t & );
    private void InternalSetWinner(int );
    private void HandleRandomOwnerControlPoints();
    private struct string_t m_iszTeamBaseIcons[32];
    private int m_iTeamBaseIcons[32];
    private struct string_t m_iszCapLayoutInHUD;
    private int m_iInvalidCapWinner;
    private bool m_bSwitchTeamsOnWin;
    private bool m_bFirstRoundAfterRestart;
    private class COutputEvent m_OnWonByTeam1;
    private class COutputEvent m_OnWonByTeam2;
    public void CTeamControlPointMaster(class CTeamControlPointMaster & );
    public void CTeamControlPointMaster();
    public void ~CTeamControlPointMaster();
    public class CTeamControlPointMaster & operator=(class CTeamControlPointMaster & );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};