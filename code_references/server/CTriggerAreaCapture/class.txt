class CTriggerAreaCapture : public CBaseTrigger
{
    public void CTriggerAreaCapture(class CTriggerAreaCapture & );
    public void CTriggerAreaCapture();
    public void DisplayCapHintTo(class CBaseMultiplayerPlayer * );
    public void OnEndCapture(int );
    public void Spawn();
    public void Precache();
    public bool KeyValue(char * ,char * );
    public void SetAreaIndex(int );
    public bool IsActive();
    public bool CheckIfDeathCausesBlock(class CBaseMultiplayerPlayer * ,class CBaseMultiplayerPlayer * );
    public void UpdateNumPlayers();
    public void UpdateOwningTeam();
    public void UpdateCappingTeam(int );
    public void UpdateTeamInZone();
    public void UpdateBlocked();
    public void ForceOwner(int );
    public bool TeamCanCap(int );
    public class CHandle<CTeamControlPoint> GetControlPoint();
    private void StartTouch(class CBaseEntity * );
    private void AreaTouch(class CBaseEntity * );
    private void EndTouch(class CBaseEntity * );
    private void CaptureThink();
    private void StartCapture(int ,int );
    private void EndCapture(int );
    private void BreakCapture(bool );
    private void IncrementCapAttemptNumber();
    private void SwitchCapture(int );
    private void SendNumPlayers();
    private void SetOwner(int );
    private void InputRoundSpawn(struct inputdata_t & );
    private void InputSetTeamCanCap(struct inputdata_t & );
    private void SetCapTimeRemaining(float );
    private void HandleRespawnTimeAdjustments(int ,int );
    private int m_iCapMode;
    private bool m_bCapturing;
    private int m_nCapturingTeam;
    private int m_nOwningTeam;
    private int m_nTeamInZone;
    private float m_flCapTime;
    private float m_fTimeRemaining;
    private float m_flLastReductionTime;
    private bool m_bBlocked;
    struct perteamdata_t
    {
        void perteamdata_t();
        int iNumRequiredToCap;
        int iNumTouching;
        int iBlockedTouching;
        bool bCanCap;
        int iSpawnAdjust;
    };
    private class CUtlVector<CTriggerAreaCapture::perteamdata_t,CUtlMemory<CTriggerAreaCapture::perteamdata_t,int> > m_TeamData;
    struct blockers_t
    {
        class CHandle<CBaseMultiplayerPlayer> hPlayer;
        int iCapAttemptNumber;
        void blockers_t(struct CTriggerAreaCapture::blockers_t & );
        void blockers_t();
    };
    private class CUtlVector<CTriggerAreaCapture::blockers_t,CUtlMemory<CTriggerAreaCapture::blockers_t,int> > m_Blockers;
    private bool m_bActive;
    private class COutputEvent m_OnStartTeam1;
    private class COutputEvent m_OnStartTeam2;
    private class COutputEvent m_OnBreakTeam1;
    private class COutputEvent m_OnBreakTeam2;
    private class COutputEvent m_OnCapTeam1;
    private class COutputEvent m_OnCapTeam2;
    private class COutputEvent m_StartOutput;
    private class COutputEvent m_BreakOutput;
    private class COutputEvent m_CapOutput;
    private int m_iAreaIndex;
    private class CHandle<CTeamControlPoint> m_hPoint;
    private bool m_bRequiresObject;
    private struct string_t m_iszCapPointName;
    private int m_iCapAttemptNumber;
    private struct datamap_t m_DataMap;
    private struct datamap_t * GetBaseMap();
    private struct datamap_t * GetDataDescMap();
    public void ~CTriggerAreaCapture();
    public class CTriggerAreaCapture & operator=(class CTriggerAreaCapture & );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};