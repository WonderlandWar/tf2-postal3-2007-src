class CBaseEntity : public IServerEntity
{
    public void Debug_Pause(bool );
    public bool Debug_IsPaused();
    public void Debug_SetSteps(int );
    public bool Debug_ShouldStep();
    public bool Debug_Step();
    public bool m_bInDebugSelect;
    public int m_nDebugPlayer;
    protected bool m_bDebugPause;
    protected int m_nDebugSteps;
    protected bool sm_bDisableTouchFuncs;
    public bool sm_bAccurateTriggerBboxChecks;
    private void CBaseEntity(class CBaseEntity & );
    public void CBaseEntity(bool );
    public void ~CBaseEntity();
    public class ServerClass * GetServerClass();
    public class SendTable * m_pClassSendTable;
    public int YouForgotToImplementOrDeclareServerClass();
    public struct datamap_t m_DataMap;
    public struct datamap_t * GetBaseMap();
    public struct datamap_t * GetDataDescMap();
    public void * operator new(unsigned int ,int ,char * ,int );
    public void * operator new(unsigned int );
    public void operator delete(void * ,int ,char * ,int );
    public void operator delete(void * );
    public class CBaseEntity * CreatePredictedEntityByName(char * ,char * ,int ,bool );
    public void SetRefEHandle(class CBaseHandle & );
    public class CBaseHandle & GetRefEHandle();
    public class ICollideable * GetCollideable();
    public class IServerNetworkable * GetNetworkable();
    public class CBaseEntity * GetBaseEntity();
    public void SetModelIndex(int );
    public int GetModelIndex();
    public struct string_t GetModelName();
    public bool TestCollision(struct Ray_t & ,unsigned int ,class CGameTrace & );
    public bool TestHitboxes(struct Ray_t & ,unsigned int ,class CGameTrace & );
    public void ComputeWorldSpaceSurroundingBox(class Vector * ,class Vector * );
    public class CCollisionProperty * CollisionProp();
    public class CCollisionProperty * CollisionProp();
    public class CServerNetworkProperty * NetworkProp();
    public class CServerNetworkProperty * NetworkProp();
    public bool IsCurrentlyTouching();
    public class Vector & GetAbsOrigin();
    public class QAngle & GetAbsAngles();
    public enum SolidType_t GetSolid();
    public int GetSolidFlags();
    public int GetEFlags();
    public void SetEFlags(int );
    public void AddEFlags(int );
    public void RemoveEFlags(int );
    public bool IsEFlagSet(int );
    public void RecalcHasPlayerChildBit();
    public bool DoesHavePlayerChild();
    public bool IsTransparent();
    public void SetNavIgnore(float );
    public void ClearNavIgnore();
    public bool IsNavIgnored();
    public bool IsFloating();
    public bool ShouldCollide(int ,int );
    public enum MoveType_t GetMoveType();
    public enum MoveCollide_t GetMoveCollide();
    public void SetMoveType(enum MoveType_t ,enum MoveCollide_t );
    public void SetMoveCollide(enum MoveCollide_t );
    public struct matrix3x4_t & EntityToWorldTransform();
    public struct matrix3x4_t & EntityToWorldTransform();
    public void EntityToWorldSpace(class Vector & ,class Vector * );
    public void WorldToEntitySpace(class Vector & ,class Vector * );
    public struct matrix3x4_t & GetParentToWorldTransform(struct matrix3x4_t & );
    public bool HasDataObjectType(int );
    public void AddDataObjectType(int );
    public void RemoveDataObjectType(int );
    public void * GetDataObject(int );
    public void * CreateDataObject(int );
    public void DestroyDataObject(int );
    public void DestroyAllDataObjects();
    public class CBaseEntity * GetOwnerEntity();
    public void SetOwnerEntity(class CBaseEntity * );
    public void SetEffectEntity(class CBaseEntity * );
    public class CBaseEntity * GetEffectEntity();
    public int ShouldTransmit(class CCheckTransmitInfo * );
    public int SetTransmitState(int );
    public int GetTransmitState();
    public int DispatchUpdateTransmitState();
    public int UpdateTransmitState();
    public void IncrementTransmitStateOwnedCounter();
    public void DecrementTransmitStateOwnedCounter();
    public void SetTransmit(class CCheckTransmitInfo * ,bool );
    public bool DetectInSkybox();
    public class CSkyCamera * GetEntitySkybox();
    public bool IsSimulatedEveryTick();
    public bool IsAnimatedEveryTick();
    public void SetSimulatedEveryTick(bool );
    public void SetAnimatedEveryTick(bool );
    public char * GetTracerType();
    public struct edict_t * edict();
    public struct edict_t * edict();
    public int entindex();
    public int GetSoundSourceIndex();
    public void FollowEntity(class CBaseEntity * ,bool );
    public void StopFollowingEntity();
    public bool IsFollowingEntity();
    public class CBaseEntity * GetFollowedEntity();
    public void Spawn();
    public void Precache();
    public void SetModel(char * );
    public void PostConstructor(char * );
    public void PostClientActive();
    public void ParseMapData(class CEntityMapData * );
    public bool KeyValue(char * ,class Vector & );
    public bool KeyValue(char * ,float );
    public bool KeyValue(char * ,char * );
    public bool GetKeyValue(char * ,char * ,int );
    public void ValidateEntityConnections();
    public void FireNamedOutput(char * ,class variant_t ,class CBaseEntity * ,class CBaseEntity * ,float );
    public void Activate();
    public void PostClientMessagesSent();
    public class CBaseEntity * GetMoveParent();
    public class CBaseEntity * GetRootMoveParent();
    public class CBaseEntity * FirstMoveChild();
    public class CBaseEntity * NextMovePeer();
    public void SetName(struct string_t );
    public void SetParent(class CBaseEntity * ,int );
    public void SetParent(struct string_t ,class CBaseEntity * ,int );
    public class CBaseEntity * GetParent();
    public int GetParentAttachment();
    public struct string_t GetEntityName();
    public bool NameMatches(struct string_t );
    public bool NameMatches(char * );
    public bool ClassMatches(struct string_t );
    public bool ClassMatches(char * );
    private bool NameMatchesComplex(char * );
    private bool ClassMatchesComplex(char * );
    private void TransformStepData_WorldToParent(class CBaseEntity * );
    private void TransformStepData_ParentToParent(class CBaseEntity * ,class CBaseEntity * );
    private void TransformStepData_ParentToWorld(class CBaseEntity * );
    public int GetSpawnFlags();
    public void AddSpawnFlags(int );
    public void RemoveSpawnFlags(int );
    public void ClearSpawnFlags();
    public bool HasSpawnFlags(int );
    public int GetEffects();
    public void AddEffects(int );
    public void RemoveEffects(int );
    public void ClearEffects();
    public void SetEffects(int );
    public bool IsEffectActive(int );
    public void MakeDormant();
    public int IsDormant();
    public void RemoveDeferred();
    public bool IsMarkedForDeletion();
    public int ObjectCaps();
    public bool AcceptInput(char * ,class CBaseEntity * ,class CBaseEntity * ,class variant_t ,int );
    public void InputAlternativeSorting(struct inputdata_t & );
    public void InputAlpha(struct inputdata_t & );
    public void InputColor(struct inputdata_t & );
    public void InputSetParent(struct inputdata_t & );
    public void SetParentAttachment(char * ,char * ,bool );
    public void InputSetParentAttachment(struct inputdata_t & );
    public void InputSetParentAttachmentMaintainOffset(struct inputdata_t & );
    public void InputClearParent(struct inputdata_t & );
    public void InputSetTeam(struct inputdata_t & );
    public void InputUse(struct inputdata_t & );
    public void InputKill(struct inputdata_t & );
    public void InputKillHierarchy(struct inputdata_t & );
    public void InputSetDamageFilter(struct inputdata_t & );
    public void InputDispatchEffect(struct inputdata_t & );
    public void InputEnableDamageForces(struct inputdata_t & );
    public void InputDisableDamageForces(struct inputdata_t & );
    public void InputAddContext(struct inputdata_t & );
    public void InputRemoveContext(struct inputdata_t & );
    public void InputClearContext(struct inputdata_t & );
    public void InputDispatchResponse(struct inputdata_t & );
    public void InputDisableShadow(struct inputdata_t & );
    public void InputEnableShadow(struct inputdata_t & );
    public void InputAddOutput(struct inputdata_t & );
    public void InputFireUser1(struct inputdata_t & );
    public void InputFireUser2(struct inputdata_t & );
    public void InputFireUser3(struct inputdata_t & );
    public void InputFireUser4(struct inputdata_t & );
    public void GetInputDispatchEffectPosition(char * ,class Vector & ,class QAngle & );
    public bool ReadKeyField(char * ,class variant_t * );
    public void SetClassname(char * );
    public char * GetClassname();
    public void EntityText(int ,char * ,float ,int ,int ,int ,int );
    public char * GetDebugName();
    public void DrawDebugGeometryOverlays();
    public int DrawDebugTextOverlays();
    public void DrawTimedOverlays();
    public void DrawBBoxOverlay();
    public void DrawAbsBoxOverlay();
    public void DrawRBoxOverlay();
    public void DrawInputOverlay(char * ,class CBaseEntity * ,class variant_t );
    public void DrawOutputOverlay(class CEventAction * );
    public void SendDebugPivotOverlay();
    public void AddTimedOverlay(char * ,int );
    public void SetSolid(enum SolidType_t );
    public int Save(class ISave & );
    public int Restore(class IRestore & );
    public bool ShouldSavePhysics();
    public void OnSave(class IEntitySaveUtils * );
    public void OnRestore();
    public int GetTextureFrameIndex();
    public void SetTextureFrameIndex(int );
    public void SetBlocksLOS(bool );
    public bool BlocksLOS();
    public void SetAIWalkable(bool );
    public bool IsAIWalkable();
    private int SaveDataDescBlock(class ISave & ,struct datamap_t * );
    private int RestoreDataDescBlock(class IRestore & ,struct datamap_t * );
    public void NetworkStateChanged(void * );
    public void NetworkStateChanged();
    public void CalcAbsolutePosition();
    public int RequiredEdictIndex();
    public void  ( * m_pfnMoveDone)();
    public void MoveDone();
    public class CBaseEntity * Instance(int );
    public class CBaseEntity * Instance(struct edict_t * );
    public class CBaseEntity * Instance(struct edict_t * );
    public class CBaseEntity * Instance(class CBaseHandle & );
    public void  ( * m_pfnThink)();
    public void Think();
    public int RegisterThinkContext(char * );
    public void  ( * )() ThinkSet(void  ( * )(),float ,char * );
    private void SetNextThink(int ,float );
    public void SetNextThink(float ,char * );
    private float GetNextThink(int );
    public float GetNextThink(char * );
    public float GetLastThink(char * );
    private int GetNextThinkTick(int );
    public int GetNextThinkTick(char * );
    public int GetLastThinkTick(char * );
    public float GetAnimTime();
    public void SetAnimTime(float );
    public float GetSimulationTime();
    public void SetSimulationTime(float );
    public void SetRenderMode(enum RenderMode_t );
    public enum RenderMode_t GetRenderMode();
    public struct string_t m_iClassname;
    public struct string_t m_iGlobalname;
    public struct string_t m_iParent;
    public int m_iHammerID;
    public float m_flSpeed;
    class NetworkVar_m_nRenderFX
    {
        public void NetworkStateChanged(void * );
    };
    public class CNetworkVarBase<unsigned char,CBaseEntity::NetworkVar_m_nRenderFX> m_nRenderFX;
    class NetworkVar_m_nRenderMode
    {
        public void NetworkStateChanged(void * );
    };
    public class CNetworkVarBase<unsigned char,CBaseEntity::NetworkVar_m_nRenderMode> m_nRenderMode;
    class NetworkVar_m_nModelIndex
    {
        public void NetworkStateChanged(void * );
    };
    public class CNetworkVarBase<short,CBaseEntity::NetworkVar_m_nModelIndex> m_nModelIndex;
    class NetworkVar_m_clrRender
    {
        public void NetworkStateChanged(void * );
    };
    public class CNetworkColor32Base<color32_s,CBaseEntity::NetworkVar_m_clrRender> m_clrRender;
    public const struct color32_s GetRenderColor();
    public void SetRenderColor(unsigned int ,unsigned int ,unsigned int ,unsigned int );
    public void SetRenderColor(unsigned int ,unsigned int ,unsigned int );
    public void SetRenderColorR(unsigned int );
    public void SetRenderColorG(unsigned int );
    public void SetRenderColorB(unsigned int );
    public void SetRenderColorA(unsigned int );
    public float m_flPrevAnimTime;
    class NetworkVar_m_flAnimTime
    {
        public void NetworkStateChanged(void * );
    };
    public class CNetworkVarBase<float,CBaseEntity::NetworkVar_m_flAnimTime> m_flAnimTime;
    class NetworkVar_m_flSimulationTime
    {
        public void NetworkStateChanged(void * );
    };
    public class CNetworkVarBase<float,CBaseEntity::NetworkVar_m_flSimulationTime> m_flSimulationTime;
    public int m_nLastThinkTick;
    class NetworkVar_m_PredictableID
    {
        public void NetworkStateChanged(void * );
    };
    public class CNetworkVarBase<CPredictableId,CBaseEntity::NetworkVar_m_PredictableID> m_PredictableID;
    public int touchStamp;
    enum thinkmethods_t
    {
        THINK_FIRE_ALL_FUNCTIONS=0,
        THINK_FIRE_BASE_ONLY=1,
        THINK_FIRE_ALL_BUT_BASE=2
    };
    protected int GetIndexForThinkContext(char * );
    protected class CUtlVector<thinkfunc_t,CUtlMemory<thinkfunc_t,int> > m_aThinkFunctions;
    protected void RemoveExpiredConcepts();
    protected int GetContextCount();
    protected char * GetContextName(int );
    protected char * GetContextValue(int );
    protected bool ContextExpired(int );
    protected int FindContextByName(char * );
    public void AddContext(char * );
    protected class CUtlVector<ResponseContext_t,CUtlMemory<ResponseContext_t,int> > m_ResponseContexts;
    protected struct string_t m_iszResponseContext;
    private void NetworkStateChanged_m_nNextThinkTick(void * );
    private void NetworkStateChanged_m_nNextThinkTick();
    class NetworkVar_m_nNextThinkTick
    {
        public void NetworkStateChanged(void * );
    };
    private class CNetworkVarBase<int,CBaseEntity::NetworkVar_m_nNextThinkTick> m_nNextThinkTick;
    class NetworkVar_m_fEffects
    {
        public void NetworkStateChanged(void * );
    };
    private class CNetworkVarBase<int,CBaseEntity::NetworkVar_m_fEffects> m_fEffects;
    public class CBaseAnimating * GetBaseAnimating();
    public class IResponseSystem * GetResponseSystem();
    public void DispatchResponse(char * );
    public enum Class_T Classify();
    public void DeathNotice(class CBaseEntity * );
    public bool ShouldAttractAutoAim(class CBaseEntity * );
    public float GetAutoAimRadius();
    public class Vector GetAutoAimCenter();
    public class ITraceFilter * GetBeamTraceFilter();
    public void DispatchTraceAttack(class CTakeDamageInfo & ,class Vector & ,class CGameTrace * );
    public bool PassesDamageFilter(class CTakeDamageInfo & );
    protected void TraceAttack(class CTakeDamageInfo & ,class Vector & ,class CGameTrace * );
    public bool CanBeHitByMeleeAttack(class CBaseEntity * );
    public int OnTakeDamage(class CTakeDamageInfo & );
    public void TakeDamage(class CTakeDamageInfo & );
    public int TakeHealth(float ,int );
    public bool IsAlive();
    public void Event_Killed(class CTakeDamageInfo & );
    public void Event_KilledOther(class CBaseEntity * ,class CTakeDamageInfo & );
    public int BloodColor();
    public void TraceBleed(float ,class Vector & ,class CGameTrace * ,int );
    public bool IsTriggered(class CBaseEntity * );
    public bool IsNPC();
    public class CAI_BaseNPC * MyNPCPointer();
    public class CBaseCombatCharacter * MyCombatCharacterPointer();
    public float GetDelay();
    public bool IsMoving();
    public bool IsWorld();
    public char * DamageDecal(int ,int );
    public void DecalTrace(class CGameTrace * ,char * );
    public void ImpactTrace(class CGameTrace * ,int ,char * );
    public void AddPoints(int ,bool );
    public void AddPointsToTeam(int ,bool );
    public void RemoveAllDecals();
    public bool OnControls(class CBaseEntity * );
    public bool HasTarget(struct string_t );
    public bool IsPlayer();
    public bool IsNetClient();
    public bool IsTemplate();
    public bool IsBaseObject();
    public bool IsBSPModel();
    public bool IsInWorld();
    public class IServerVehicle * GetServerVehicle();
    public bool IsViewable();
    public class CTeam * GetTeam();
    public int GetTeamNumber();
    public void ChangeTeam(int );
    public bool IsInTeam(class CTeam * );
    public bool InSameTeam(class CBaseEntity * );
    public bool IsInAnyTeam();
    public char * TeamID();
    public void OnEntityEvent(enum EntityEvent_t ,void * );
    public bool IsStandable();
    public bool CanStandOn(struct edict_t * );
    public bool CanStandOn(class CBaseEntity * );
    public class CBaseEntity * GetEnemy();
    public class CBaseEntity * GetEnemy();
    public void ViewPunch(class QAngle & );
    public void VelocityPunch(class Vector & );
    public class CBaseEntity * GetNextTarget();
    public void  ( * m_pfnTouch)(class CBaseEntity * );
    public void  ( * m_pfnUse)(class CBaseEntity * ,class CBaseEntity * ,enum USE_TYPE ,float );
    public void  ( * m_pfnBlocked)(class CBaseEntity * );
    public void Use(class CBaseEntity * ,class CBaseEntity * ,enum USE_TYPE ,float );
    public void StartTouch(class CBaseEntity * );
    public void Touch(class CBaseEntity * );
    public void EndTouch(class CBaseEntity * );
    public void StartBlocked(class CBaseEntity * );
    public void Blocked(class CBaseEntity * );
    public void EndBlocked();
    public void PhysicsSimulate();
    public class CGameTrace & GetTouchTrace();
    public void PhysicsImpact(class CBaseEntity * ,class CGameTrace & );
    public void PhysicsMarkEntitiesAsTouching(class CBaseEntity * ,class CGameTrace & );
    public void PhysicsMarkEntitiesAsTouchingEventDriven(class CBaseEntity * ,class CGameTrace & );
    public void PhysicsTouchTriggers(class Vector * );
    public void PhysicsRemoveTouchedList(class CBaseEntity * );
    public void PhysicsNotifyOtherOfUntouch(class CBaseEntity * ,class CBaseEntity * );
    public void PhysicsRemoveToucher(class CBaseEntity * ,struct touchlink_t * );
    public struct groundlink_t * AddEntityToGroundList(class CBaseEntity * );
    public void PhysicsStartGroundContact(class CBaseEntity * );
    public void PhysicsNotifyOtherOfGroundRemoval(class CBaseEntity * ,class CBaseEntity * );
    public void PhysicsRemoveGround(class CBaseEntity * ,struct groundlink_t * );
    public void PhysicsRemoveGroundList(class CBaseEntity * );
    public void StartGroundContact(class CBaseEntity * );
    public void EndGroundContact(class CBaseEntity * );
    public void SetGroundChangeTime(float );
    public float GetGroundChangeTime();
    public void WakeRestingObjects();
    public bool HasNPCsOnIt();
    public void UpdateOnRemove();
    public void StopLoopingSounds();
    public void SUB_Remove();
    public void SUB_DoNothing();
    public void SUB_StartFadeOut(float ,bool );
    public void SUB_StartFadeOutInstant();
    public void SUB_FadeOut();
    public void SUB_Vanish();
    public void SUB_CallUseToggle();
    public void SUB_PerformFadeOut();
    public bool SUB_AllowedToFade();
    public void Teleport(class Vector * ,class QAngle * ,class Vector * );
    public void NotifySystemEvent(class CBaseEntity * ,enum notify_system_event_t ,struct notify_system_event_params_t & );
    public int ShouldToggle(enum USE_TYPE ,int );
    public void MakeTracer(class Vector & ,class CGameTrace & ,int );
    public int GetTracerAttachment();
    public void FireBullets(int ,class Vector & ,class Vector & ,class Vector & ,float ,int ,int ,int ,int ,int ,class CBaseEntity * ,bool ,bool );
    public void FireBullets(struct FireBulletsInfo_t & );
    public void DoImpactEffect(class CGameTrace & ,int );
    public class CBaseEntity * Respawn();
    public void TraceAttackToTriggers(class CTakeDamageInfo & ,class Vector & ,class Vector & ,class Vector & );
    public bool Intersects(class CBaseEntity * );
    public bool IsLockedByMaster();
    public int GetMaxHealth();
    public void SetMaxHealth(int );
    public int GetHealth();
    public void SetHealth(int );
    public void ModifyOrAppendCriteria(class AI_CriteriaSet & );
    public void AppendContextToCriteria(class AI_CriteriaSet & ,char * );
    public void DumpResponseCriteria();
    private class CBaseEntity * m_pLink;
    public struct string_t m_target;
    public void NetworkStateChanged_m_iMaxHealth(void * );
    public void NetworkStateChanged_m_iMaxHealth();
    class NetworkVar_m_iMaxHealth
    {
        public void NetworkStateChanged(void * );
    };
    public class CNetworkVarBase<int,CBaseEntity::NetworkVar_m_iMaxHealth> m_iMaxHealth;
    public void NetworkStateChanged_m_iHealth(void * );
    public void NetworkStateChanged_m_iHealth();
    class NetworkVar_m_iHealth
    {
        public void NetworkStateChanged(void * );
    };
    public class CNetworkVarBase<int,CBaseEntity::NetworkVar_m_iHealth> m_iHealth;
    public void NetworkStateChanged_m_lifeState(void * );
    public void NetworkStateChanged_m_lifeState();
    class NetworkVar_m_lifeState
    {
        public void NetworkStateChanged(void * );
    };
    public class CNetworkVarBase<char,CBaseEntity::NetworkVar_m_lifeState> m_lifeState;
    public void NetworkStateChanged_m_takedamage(void * );
    public void NetworkStateChanged_m_takedamage();
    class NetworkVar_m_takedamage
    {
        public void NetworkStateChanged(void * );
    };
    public class CNetworkVarBase<char,CBaseEntity::NetworkVar_m_takedamage> m_takedamage;
    public struct string_t m_iszDamageFilterName;
    public class CHandle<CBaseEntity> m_hDamageFilter;
    public int m_debugOverlays;
    public struct TimedOverlay_t * m_pTimedOverlay;
    public class CBaseEntity * Create(char * ,class Vector & ,class QAngle & ,class CBaseEntity * );
    public class CBaseEntity * CreateNoSpawn(char * ,class Vector & ,class QAngle & ,class CBaseEntity * );
    public int GetCollisionGroup();
    public void SetCollisionGroup(int );
    public void CollisionRulesChanged();
    public int GetDamageType();
    public float GetDamage();
    public void SetDamage(float );
    public class Vector EyePosition();
    public class Vector EyePosition();
    public class QAngle & EyeAngles();
    public class QAngle & EyeAngles();
    public class QAngle & LocalEyeAngles();
    public class QAngle & LocalEyeAngles();
    public class Vector EarPosition();
    public class Vector EarPosition();
    public class Vector BodyTarget(class Vector & ,bool );
    public class Vector HeadTarget(class Vector & );
    public void GetVectors(class Vector * ,class Vector * ,class Vector * );
    public class Vector & GetViewOffset();
    public class Vector & GetViewOffset();
    public void SetViewOffset(class Vector & );
    public void SetLocalVelocity(class Vector & );
    public void ApplyLocalVelocityImpulse(class Vector & );
    public void SetAbsVelocity(class Vector & );
    public void ApplyAbsVelocityImpulse(class Vector & );
    public void ApplyLocalAngularVelocityImpulse(class Vector & );
    public class Vector & GetLocalVelocity();
    public class Vector & GetAbsVelocity();
    public void SetLocalAngularVelocity(class QAngle & );
    public class QAngle & GetLocalAngularVelocity();
    public class Vector & GetBaseVelocity();
    public void SetBaseVelocity(class Vector & );
    public class Vector GetSmoothedVelocity();
    public void GetVelocity(class Vector * ,class Vector * );
    public float GetGravity();
    public void SetGravity(float );
    public float GetFriction();
    public void SetFriction(float );
    public bool FVisible(class Vector & ,int ,class CBaseEntity ** );
    public bool FVisible(class CBaseEntity * ,int ,class CBaseEntity ** );
    public bool CanBeSeenBy(class CAI_BaseNPC * );
    public float GetAttackDamageScale(class CBaseEntity * );
    public float GetReceivedDamageScale(class CBaseEntity * );
    public void SetCheckUntouch(bool );
    public bool GetCheckUntouch();
    public void SetGroundEntity(class CBaseEntity * );
    public class CBaseEntity * GetGroundEntity();
    public class CBaseEntity * GetGroundEntity();
    public void GetGroundVelocityToApply(class Vector & );
    public int GetWaterLevel();
    public void SetWaterLevel(int );
    public int GetWaterType();
    public void SetWaterType(int );
    public bool PhysicsSplash(class Vector & ,class Vector & ,float ,float );
    public void Splash();
    public void ClearSolidFlags();
    public void RemoveSolidFlags(int );
    public void AddSolidFlags(int );
    public bool IsSolidFlagSet(int );
    public void SetSolidFlags(int );
    public bool IsSolid();
    public void SetModelName(struct string_t );
    public struct model_t * GetModel();
    public class Vector & WorldAlignMins();
    public class Vector & WorldAlignMaxs();
    public void SetCollisionBounds(class Vector & ,class Vector & );
    public class Vector & WorldSpaceCenter();
    public class Vector & WorldAlignSize();
    public float BoundingRadius();
    public bool IsPointSized();
    public void SetAbsOrigin(class Vector & );
    public void SetAbsAngles(class QAngle & );
    public void SetLocalOrigin(class Vector & );
    public class Vector & GetLocalOrigin();
    public void SetLocalAngles(class QAngle & );
    public class QAngle & GetLocalAngles();
    public void SetElasticity(float );
    public float GetElasticity();
    public void SetShadowCastDistance(float ,float );
    public void SetShadowCastDistance(float );
    public float GetShadowCastDistance();
    public float GetLocalTime();
    public void IncrementLocalTime(float );
    public float GetMoveDoneTime();
    public void SetMoveDoneTime(float );
    public class Vector GetSoundEmissionOrigin();
    public void AddFlag(int );
    public void RemoveFlag(int );
    public void ToggleFlag(int );
    public int GetFlags();
    public void ClearFlags();
    public void SetLocalTransform(struct matrix3x4_t & );
    public void EmitSound(class IRecipientFilter & ,int ,struct EmitSound_t & ,int & );
    public void EmitSound(class IRecipientFilter & ,int ,struct EmitSound_t & );
    public void EmitSound(class IRecipientFilter & ,int ,char * ,int & ,class Vector * ,float ,float * );
    public void EmitSound(class IRecipientFilter & ,int ,char * ,class Vector * ,float ,float * );
    public void EmitSound(char * ,int & ,float ,float * );
    public void EmitSound(char * ,float ,float * );
    public void StopSound(int ,int ,char * );
    public void StopSound(int ,char * );
    public void StopSound(char * ,int & );
    public void StopSound(char * );
    public void GenderExpandString(char * ,char * ,int );
    public float GetSoundDuration(char * ,char * );
    public bool GetParametersForSound(char * ,int & ,struct CSoundParameters & ,char * );
    public bool GetParametersForSound(char * ,struct CSoundParameters & ,char * );
    public enum soundlevel_t LookupSoundLevel(char * ,int & );
    public enum soundlevel_t LookupSoundLevel(char * );
    public void EmitAmbientSound(int ,class Vector & ,char * ,int ,float ,float * );
    public int PrecacheScriptSound(char * );
    public void PrefetchScriptSound(char * );
    public void RemoveRecipientsIfNotCloseCaptioning(class CRecipientFilter & );
    public void EmitCloseCaption(class IRecipientFilter & ,int ,char * ,class CUtlVector<Vector,CUtlMemory<Vector,int> > & ,float ,bool );
    public void EmitSentenceByIndex(class IRecipientFilter & ,int ,int ,int ,float ,enum soundlevel_t ,int ,int ,class Vector * ,class Vector * ,bool ,float );
    public bool IsPrecacheAllowed();
    public void SetAllowPrecache(bool );
    public bool m_bAllowPrecache;
    public bool IsSimulatingOnAlternateTicks();
    public bool CreateVPhysics();
    public class IPhysicsObject * VPhysicsInitStatic();
    public class IPhysicsObject * VPhysicsInitNormal(enum SolidType_t ,int ,bool ,struct solid_t * );
    public class IPhysicsObject * VPhysicsInitShadow(bool ,bool ,struct solid_t * );
    public bool ForceVPhysicsCollide(class CBaseEntity * );
    private bool VPhysicsInitSetup();
    public void VPhysicsSetObject(class IPhysicsObject * );
    public void VPhysicsDestroyObject();
    public void VPhysicsSwapObject(class IPhysicsObject * );
    public class IPhysicsObject * VPhysicsGetObject();
    public void VPhysicsUpdate(class IPhysicsObject * );
    public void VPhysicsUpdatePusher(class IPhysicsObject * );
    public int VPhysicsTakeDamage(class CTakeDamageInfo & );
    public void VPhysicsShadowCollision(int ,struct gamevcollisionevent_t * );
    public void VPhysicsShadowUpdate(class IPhysicsObject * );
    public void VPhysicsCollision(int ,struct gamevcollisionevent_t * );
    public void VPhysicsFriction(class IPhysicsObject * ,float ,int ,int );
    public void UpdatePhysicsShadowToCurrentPosition(float );
    public int VPhysicsGetObjectList(class IPhysicsObject ** ,int );
    public bool VPhysicsIsFlesh();
    public void SetPlayerSimulated(class CBasePlayer * );
    public void UnsetPlayerSimulated();
    public bool IsPlayerSimulated();
    public class CBasePlayer * GetSimulatingPlayer();
    public void PhysicsCheckForEntityUntouch();
    public bool PhysicsRunThink(enum CBaseEntity::thinkmethods_t );
    public bool PhysicsRunSpecificThink(int ,void  ( * )());
    public bool PhysicsTestEntityPosition(class CBaseEntity ** );
    public void PhysicsPushEntity(class Vector & ,class CGameTrace * );
    public bool PhysicsCheckWater();
    public void PhysicsCheckWaterTransition();
    public void PhysicsStepRecheckGround();
    public void UpdateWaterState();
    public bool IsEdictFree();
    public class CBasePlayer * HasPhysicsAttacker(float );
    public unsigned int PhysicsSolidMaskForEntity();
    public void ComputeAbsPosition(class Vector & ,class Vector * );
    public void ComputeAbsDirection(class Vector & ,class Vector * );
    public void SetPredictionEligible(bool );
    protected void InvalidatePhysicsRecursive(int );
    protected int PhysicsClipVelocity(class Vector & ,class Vector & ,class Vector & ,float );
    protected void PhysicsRelinkChildren();
    protected void PerformFlyCollisionResolution(class CGameTrace & ,class Vector & );
    protected void ResolveFlyCollisionBounce(class CGameTrace & ,class Vector & ,float );
    protected void ResolveFlyCollisionSlide(class CGameTrace & ,class Vector & );
    protected void ResolveFlyCollisionCustom(class CGameTrace & ,class Vector & );
    private void PhysicsStep();
    private void PhysicsPusher();
    private void PhysicsNone();
    private void PhysicsNoclip();
    private void PhysicsStepRunTimestep(float );
    private void PhysicsToss();
    private void PhysicsCustom();
    private void PerformPush(float );
    private void PhysicsRigidChild();
    private void UpdateBaseVelocity();
    private void PerformCustomPhysics(class Vector * ,class Vector * ,class QAngle * ,class QAngle * );
    private void PhysicsDispatchThink(void  ( * )());
    private struct touchlink_t * PhysicsMarkEntityAsTouched(class CBaseEntity * );
    private void PhysicsTouch(class CBaseEntity * );
    private void PhysicsStartTouch(class CBaseEntity * );
    private class CBaseEntity * PhysicsPushMove(float );
    private class CBaseEntity * PhysicsPushRotate(float );
    private class CBaseEntity * PhysicsCheckRotateMove(struct rotatingpushmove_t & ,class CBaseEntity ** ,int );
    private class CBaseEntity * PhysicsCheckPushMove(class Vector & ,class CBaseEntity ** ,int );
    private int PhysicsTryMove(float ,class CGameTrace * );
    private void PhysicsCheckVelocity();
    private void PhysicsAddHalfGravity(float );
    private void PhysicsAddGravityMove(class Vector & );
    private void CalcAbsoluteVelocity();
    private void CalcAbsoluteAngularVelocity();
    private void PhysicsCheckSweep(class Vector & ,class Vector & ,class CGameTrace * );
    private void SimulateAngles(float );
    private void CheckStepSimulationChanged();
    private void StepSimulationThink(float );
    private bool ComputeStepSimulationNetworkOrigin(struct StepSimulationData * );
    private bool ComputeStepSimulationNetworkAngles(struct StepSimulationData * );
    public bool AddStepDiscontinuity(float ,class Vector & ,class QAngle & );
    public int GetFirstThinkTick();
    private class Vector GetStepOrigin();
    private class QAngle GetStepAngles();
    private void CheckHasThinkFunction(bool );
    private void CheckHasGamePhysicsSimulation();
    private bool WillThink();
    private bool WillSimulateGamePhysics();
    private void SetLastThink(int ,float );
    private void UpdateShotStatistics(class CGameTrace & );
    private bool HandleShotImpactingWater(struct FireBulletsInfo_t & ,class Vector & ,class ITraceFilter * ,class Vector * );
    private void HandleShotImpactingGlass(struct FireBulletsInfo_t & ,class CGameTrace & ,class Vector & ,class ITraceFilter * );
    private bool ShouldDrawUnderwaterBulletBubbles();
    private void ComputeTracerStartPosition(class Vector & ,class Vector * );
    private void CreateBubbleTrailTracer(class Vector & ,class Vector & ,class Vector & );
    private bool ShouldDrawWaterImpacts();
    private void ShadowCastDistThink();
    private void PrecacheModelSounds(int );
    private void PrecacheModelParticles(int );
    protected int m_nSimulationTick;
    class NetworkVar_m_spawnflags
    {
        public void NetworkStateChanged(void * );
    };
    protected class CNetworkVarBase<int,CBaseEntity::NetworkVar_m_spawnflags> m_spawnflags;
    private int m_iEFlags;
    private void NetworkStateChanged_m_fFlags(void * );
    private void NetworkStateChanged_m_fFlags();
    class NetworkVar_m_fFlags
    {
        public void NetworkStateChanged(void * );
    };
    private class CNetworkVarBase<int,CBaseEntity::NetworkVar_m_fFlags> m_fFlags;
    private struct string_t m_iName;
    private class CUtlLinkedList<CDamageModifier *,int,0,int,CUtlMemory<UtlLinkedListElem_t<CDamageModifier *,int>,int> > m_DamageModifiers;
    private class CHandle<CBaseEntity> m_pParent;
    private unsigned int m_nTransmitStateOwnedCounter;
    class NetworkVar_m_iParentAttachment
    {
        public void NetworkStateChanged(void * );
    };
    private class CNetworkVarBase<unsigned char,CBaseEntity::NetworkVar_m_iParentAttachment> m_iParentAttachment;
    class NetworkVar_m_MoveType
    {
        public void NetworkStateChanged(void * );
    };
    private class CNetworkVarBase<unsigned char,CBaseEntity::NetworkVar_m_MoveType> m_MoveType;
    class NetworkVar_m_MoveCollide
    {
        public void NetworkStateChanged(void * );
    };
    private class CNetworkVarBase<unsigned char,CBaseEntity::NetworkVar_m_MoveCollide> m_MoveCollide;
    class NetworkVar_m_hMoveParent
    {
        public void NetworkStateChanged(void * );
    };
    private class CNetworkHandleBase<CBaseEntity,CBaseEntity::NetworkVar_m_hMoveParent> m_hMoveParent;
    private class CHandle<CBaseEntity> m_hMoveChild;
    private class CHandle<CBaseEntity> m_hMovePeer;
    class NetworkVar_m_Collision : public CCollisionProperty
    {
        public class CBaseEntity::NetworkVar_m_Collision & operator=(class CBaseEntity::NetworkVar_m_Collision & );
        public void CopyFrom(class CCollisionProperty & );
        public void NetworkStateChanged(void * );
        public void NetworkStateChanged();
        public void NetworkVar_m_Collision(class CBaseEntity::NetworkVar_m_Collision & );
        public void NetworkVar_m_Collision();
        public void ~NetworkVar_m_Collision();
        public void * __vecDelDtor(unsigned int );
    };
    private int GetOffset_m_Collision();
    private class CBaseEntity::NetworkVar_m_Collision m_Collision;
    private class CServerNetworkProperty m_Network;
    class NetworkVar_m_hOwnerEntity
    {
        public void NetworkStateChanged(void * );
    };
    private class CNetworkHandleBase<CBaseEntity,CBaseEntity::NetworkVar_m_hOwnerEntity> m_hOwnerEntity;
    class NetworkVar_m_hEffectEntity
    {
        public void NetworkStateChanged(void * );
    };
    private class CNetworkHandleBase<CBaseEntity,CBaseEntity::NetworkVar_m_hEffectEntity> m_hEffectEntity;
    class NetworkVar_m_CollisionGroup
    {
        public void NetworkStateChanged(void * );
    };
    private class CNetworkVarBase<int,CBaseEntity::NetworkVar_m_CollisionGroup> m_CollisionGroup;
    private class IPhysicsObject * m_pPhysicsObject;
    class NetworkVar_m_flShadowCastDistance
    {
        public void NetworkStateChanged(void * );
    };
    private class CNetworkVarBase<float,CBaseEntity::NetworkVar_m_flShadowCastDistance> m_flShadowCastDistance;
    private float m_flDesiredShadowCastDistance;
    private int m_iInitialTeamNum;
    class NetworkVar_m_iTeamNum
    {
        public void NetworkStateChanged(void * );
    };
    private class CNetworkVarBase<int,CBaseEntity::NetworkVar_m_iTeamNum> m_iTeamNum;
    private unsigned int m_nWaterTouch;
    private unsigned int m_nSlimeTouch;
    private unsigned int m_nWaterType;
    private void NetworkStateChanged_m_nWaterLevel(void * );
    private void NetworkStateChanged_m_nWaterLevel();
    class NetworkVar_m_nWaterLevel
    {
        public void NetworkStateChanged(void * );
    };
    private class CNetworkVarBase<unsigned char,CBaseEntity::NetworkVar_m_nWaterLevel> m_nWaterLevel;
    private float m_flNavIgnoreUntilTime;
    private void NetworkStateChanged_m_hGroundEntity(void * );
    private void NetworkStateChanged_m_hGroundEntity();
    class NetworkVar_m_hGroundEntity
    {
        public void NetworkStateChanged(void * );
    };
    private class CNetworkHandleBase<CBaseEntity,CBaseEntity::NetworkVar_m_hGroundEntity> m_hGroundEntity;
    private float m_flGroundChangeTime;
    private struct string_t m_ModelName;
    private void NetworkStateChanged_m_vecBaseVelocity(void * );
    private void NetworkStateChanged_m_vecBaseVelocity();
    class NetworkVar_m_vecBaseVelocity
    {
        public void NetworkStateChanged(void * );
    };
    private class CNetworkVarBase<Vector,CBaseEntity::NetworkVar_m_vecBaseVelocity> m_vecBaseVelocity;
    private class Vector m_vecAbsVelocity;
    private class QAngle m_vecAngVelocity;
    private struct matrix3x4_t m_rgflCoordinateFrame;
    private class CHandle<CBaseEntity> m_pBlocker;
    private float m_flGravity;
    private void NetworkStateChanged_m_flFriction(void * );
    private void NetworkStateChanged_m_flFriction();
    class NetworkVar_m_flFriction
    {
        public void NetworkStateChanged(void * );
    };
    private class CNetworkVarBase<float,CBaseEntity::NetworkVar_m_flFriction> m_flFriction;
    class NetworkVar_m_flElasticity
    {
        public void NetworkStateChanged(void * );
    };
    private class CNetworkVarBase<float,CBaseEntity::NetworkVar_m_flElasticity> m_flElasticity;
    private float m_flLocalTime;
    private float m_flVPhysicsUpdateLocalTime;
    private float m_flMoveDoneTime;
    private int m_nPushEnumCount;
    private class Vector m_vecAbsOrigin;
    private void NetworkStateChanged_m_vecVelocity(void * );
    private void NetworkStateChanged_m_vecVelocity();
    class NetworkVar_m_vecVelocity
    {
        public void NetworkStateChanged(void * );
    };
    private class CNetworkVectorBase<Vector,CBaseEntity::NetworkVar_m_vecVelocity> m_vecVelocity;
    class NetworkVar_m_iTextureFrameIndex
    {
        public void NetworkStateChanged(void * );
    };
    private class CNetworkVarBase<unsigned char,CBaseEntity::NetworkVar_m_iTextureFrameIndex> m_iTextureFrameIndex;
    class NetworkVar_m_bSimulatedEveryTick
    {
        public void NetworkStateChanged(void * );
    };
    private class CNetworkVarBase<bool,CBaseEntity::NetworkVar_m_bSimulatedEveryTick> m_bSimulatedEveryTick;
    class NetworkVar_m_bAnimatedEveryTick
    {
        public void NetworkStateChanged(void * );
    };
    private class CNetworkVarBase<bool,CBaseEntity::NetworkVar_m_bAnimatedEveryTick> m_bAnimatedEveryTick;
    class NetworkVar_m_bAlternateSorting
    {
        public void NetworkStateChanged(void * );
    };
    private class CNetworkVarBase<bool,CBaseEntity::NetworkVar_m_bAlternateSorting> m_bAlternateSorting;
    private class COutputEvent m_OnUser1;
    private class COutputEvent m_OnUser2;
    private class COutputEvent m_OnUser3;
    private class COutputEvent m_OnUser4;
    private class QAngle m_angAbsRotation;
    class NetworkVar_m_vecOrigin
    {
        public void NetworkStateChanged(void * );
    };
    private class CNetworkVectorBase<Vector,CBaseEntity::NetworkVar_m_vecOrigin> m_vecOrigin;
    class NetworkVar_m_angRotation
    {
        public void NetworkStateChanged(void * );
    };
    private class CNetworkVectorBase<QAngle,CBaseEntity::NetworkVar_m_angRotation> m_angRotation;
    private class CBaseHandle m_RefEHandle;
    private void NetworkStateChanged_m_vecViewOffset(void * );
    private void NetworkStateChanged_m_vecViewOffset();
    class NetworkVar_m_vecViewOffset
    {
        public void NetworkStateChanged(void * );
    };
    private class CNetworkVectorBase<Vector,CBaseEntity::NetworkVar_m_vecViewOffset> m_vecViewOffset;
    class NetworkVar_m_bIsPlayerSimulated
    {
        public void NetworkStateChanged(void * );
    };
    private class CNetworkVarBase<bool,CBaseEntity::NetworkVar_m_bIsPlayerSimulated> m_bIsPlayerSimulated;
    private class CHandle<CBasePlayer> m_hPlayerSimulationOwner;
    private int m_fDataObjectTypes;
    public void SetSize(class Vector & ,class Vector & );
    public int PrecacheModel(char * );
    public bool PrecacheSound(char * );
    public void PrefetchSound(char * );
    public void Remove();
    private int m_nPredictionRandomSeed;
    private class CBasePlayer * m_pPredictionPlayer;
    public int GetPredictionRandomSeed();
    public void SetPredictionRandomSeed(class CUserCmd * );
    public class CBasePlayer * GetPredictionPlayer();
    public void SetPredictionPlayer(class CBasePlayer * );
    public bool IsServer();
    public bool IsClient();
    public char * GetDLLType();
    public class CBaseEntity & operator=(class CBaseEntity & );
    public void __dflt_ctor_closure();
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};